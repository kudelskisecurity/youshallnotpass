package validatetokencmd

import (
	"sync"

	"github.com/kudelskisecurity/youshallnotpass/pkg/checkparser"
	"github.com/kudelskisecurity/youshallnotpass/pkg/checks"
	"github.com/kudelskisecurity/youshallnotpass/pkg/loggerclient"
	scriptcleanerparser "github.com/kudelskisecurity/youshallnotpass/pkg/scriptcleanerclient"
	"github.com/kudelskisecurity/youshallnotpass/pkg/vaultclient"
	"github.com/kudelskisecurity/youshallnotpass/pkg/vaultclient/hashicorpclient"
	"github.com/kudelskisecurity/youshallnotpass/pkg/vaultclient/vaultclientparser"
	"github.com/urfave/cli/v2"
)

func Commands() []*cli.Command {
	return []*cli.Command{
		{
			Name:        "validate-token",
			Aliases:     []string{"validate"},
			Usage:       "validate-token <flags>",
			Description: `Validate Token`,
			Action:      validatetokencommand,
			Flags: []cli.Flag{
				&cli.StringFlag{
					Name:        "ci-job-image",
					EnvVars:     []string{"CI_JOB_IMAGE", "CUSTOM_ENV_CI_JOB_IMAGE"},
					Value:       "",
					DefaultText: "CI Pipeline Docker Container used to Execute the CI job",
				},
				&cli.StringFlag{
					Name:        "ci-project-path",
					EnvVars:     []string{"CI_PROJECT_PATH", "CUSTOM_ENV_CI_PROJECT_PATH"},
					Required:    true,
					DefaultText: "Path to the Repo",
				},
				&cli.StringFlag{
					Name:        "ci-project-namespace",
					EnvVars:     []string{"CI_PROJECT_NAMESPACE", "CUSTOM_ENV_CI_PROJECT_NAMESPACE"},
					Required:    true,
					DefaultText: "Namespace of the Repo",
				},
				&cli.IntFlag{
					Name:        "ci-pipeline-id",
					EnvVars:     []string{"CI_PIPELINE_ID", "CUSTOM_ENV_CI_PIPELINE_ID"},
					Value:       0,
					DefaultText: "ID of the CI pipeline job",
				},
				&cli.StringFlag{
					Name:        "ci-job-script",
					EnvVars:     []string{"RUNNER_SCRIPT"},
					Value:       "",
					DefaultText: "CI Job Script to Run",
				},
				&cli.StringFlag{
					Name:        "ci-job-name",
					EnvVars:     []string{"CI_JOB_NAME", "CUSTOM_ENV_CI_JOB_NAME"},
					Value:       "",
					DefaultText: "Name of the CI Job",
				},
				&cli.StringFlag{
					Name:        "ci-user-email",
					EnvVars:     []string{"CI_USER_EMAIL"},
					Value:       "shared",
					DefaultText: "Email of the User Executing the CI job (Username on GitHub)",
				},
				&cli.StringFlag{
					Name:        "ci-platform",
					Value:       "gitlab",
					DefaultText: "The CI/CD platform being used to run this job (i.e. GitHub, GitLab, ...)",
				},
				&cli.StringFlag{
					Name:        "vault-addr",
					EnvVars:     []string{"VAULT_ADDR"},
					DefaultText: "URL Address of the Vault Server (i.e. http://vault.example.com)",
					Required:    true,
				},
				&cli.StringFlag{
					Name:        "vault-external-addr",
					EnvVars:     []string{"VAULT_EXTERNAL_ADDR"},
					DefaultText: "Same as Vault Addr (Different in Local Testing)",
				},
				&cli.StringFlag{
					Name:        "vault-client",
					EnvVars:     []string{"VAULT_CLIENT"},
					DefaultText: "Secure Key-Value Storage Client (i.e. Hashicorp)",
					Value:       "Hashicorp",
				},
				&cli.StringFlag{
					Name:        "vault-root",
					EnvVars:     []string{"YOUSHALLNOTPASS_VAULT_ROOT"},
					DefaultText: "Vault Secret Root",
					Value:       "cicd",
					Hidden:      true,
				},
				&cli.StringFlag{
					Name:        "vault-role",
					EnvVars:     []string{"VAULT_ROLE"},
					Value:       "",
					DefaultText: "Vault role for Authentication",
				},
				&cli.StringFlag{
					Name:        "vault-login-path",
					EnvVars:     []string{"VAULT_LOGIN_PATH"},
					DefaultText: "Path to Login to the Vault Instance (must be JWT enabled)",
				},
				&cli.StringFlag{
					Name:        "vault-token",
					EnvVars:     []string{"VAULT_TOKEN"},
					DefaultText: "Token to Authenticate with Vault (Optional)",
				},
				&cli.StringFlag{
					Name:        "jwt-token",
					EnvVars:     []string{"VAULT_ID_TOKEN", "CUSTOM_ENV_VAULT_ID_TOKEN", "CI_JOB_JWT", "CUSTOM_ENV_CI_JOB_JWT"},
					DefaultText: "JWT for the CI Job",
				},
				&cli.StringFlag{
					Name:        "pre-validation-token",
					EnvVars:     []string{"YOUSHALLNOTPASS_PREVALIDATION_TOKEN"},
					DefaultText: "Random String Generated By YouShallNotPass for Multi-Step Scripts",
				},
				&cli.IntFlag{
					Name:        "timeout",
					EnvVars:     []string{"YOUSHALLNOTPASS_TIMEOUT"},
					DefaultText: "How Long to Wait for Vault Authentication until Timeout (s)",
					Value:       60 * 2,
					Hidden:      true,
				},
				&cli.StringFlag{
					Name:        "check-type",
					Value:       "all",
					DefaultText: "The type of check to run at this stage (auto generated in the custom executor)",
				},
			},
		},
	}
}

func validatetokencommand(c *cli.Context) error {
	// Extract CLI args
	vaultExternalAddr := c.String("vault-external-addr")
	ciUserEmail := c.String("ci-user-email")
	mfaValidationToken := c.String("pre-validation-token")
	ciJobImage := c.String("ci-job-image")
	ciJobScript := c.String("ci-job-script")
	ciJobName := c.String("ci-job-name")
	vaultClient := c.String("vault-client")
	vaultRoot := c.String("vault-root")
	ciProjectPath := c.String("ci-project-path")
	ciProjectNamespace := c.String("ci-project-namespace")
	ciPipelineId := c.Int("ci-pipeline-id")
	timeout := c.Int("timeout")
	checkType := c.String("check-type")
	ciPlatform := c.String("ci-platform")

	var v vaultclient.VaultClient
	var err error

	clientType, err := vaultclientparser.ParseClient(vaultClient)
	if err != nil {
		return err
	}

	if clientType == "Hashicorp" {
		v, err = hashicorpclient.InitVaultClient(c)
		if err != nil {
			return err
		}
	}

	namespaceConfigMount := vaultRoot + "/" + ciProjectNamespace + "/" + "youshallnotpass_config"
	projectConfigMount := vaultRoot + "/" + ciProjectPath + "/" + "youshallnotpass_config"

	// Parse namespace-level configuration for youshallnotpass
	namespaceConfig, namespaceConfigErr := v.GetNamespaceConfig(namespaceConfigMount)

	loggerClient, err := loggerclient.ParseNotifyClient(namespaceConfig.LoggerConfig, ciJobName, vaultExternalAddr, vaultRoot, ciProjectPath)
	if err != nil {
		return err
	}

	if namespaceConfigErr != nil {
		loggerClient.LogRecoverableError(namespaceConfigErr)
	}

	// Parse project-level configuration for youshallnotpass
	projectConfig, err := v.GetProjectConfig(projectConfigMount)
	if err != nil {
		loggerClient.LogRecoverableError(err)
	}

	cleaner, err := scriptcleanerparser.ParseCleaner(ciPlatform)
	if err != nil {
		return loggerClient.LogFailedExecution(err.Error())
	}

	scriptLines := cleaner.CleanupScript(ciJobScript)

	// Parse Checks for the Current Job
	checkConfigs := projectConfig.GetJobConfig(ciJobName)

	jobChecks, err := checkparser.ParseChecks(checkConfigs, ciJobName, ciJobImage, scriptLines, checkType, ciPlatform)
	if err != nil {
		return loggerClient.LogFailedExecution(err.Error())
	}

	// Get whitelist
	namespaceWhitelistMount := vaultRoot + "/" + ciProjectNamespace + "/" + "whitelist"
	projectWhitelistMount := vaultRoot + "/" + ciProjectPath + "/" + "whitelist"

	whitelist, err := v.ReadWhitelists(namespaceWhitelistMount, projectWhitelistMount)
	if err != nil {
		return loggerClient.LogFailedExecution(err.Error())
	}

	// Run Checks
	var checkWaitGroup sync.WaitGroup
	checkChannel := make(chan checks.CheckResult, len(jobChecks))

	checkWaitGroup.Add(len(jobChecks))
	for _, check := range jobChecks {
		check := check
		go check.Check(checkChannel, &checkWaitGroup, whitelist)
	}

	// Check Results
	checkWaitGroup.Wait()
	close(checkChannel)

	abort := false
	mfaRequired := false

	var results []checks.CheckResult
	for result := range checkChannel {
		if result.Abort {
			abort = true
		} else if result.Mfa {
			mfaRequired = true
		}

		results = append(results, result)
	}

	_ = loggerClient.LogCheckResults(results)

	if abort {
		return loggerClient.LogFailedExecution("Crucial Check Failed")
	}

	// If Necessary Run MFA
	if mfaRequired {
		// Check for prevalidation
		if vaultclient.TokenCreated(mfaValidationToken) {
			_ = loggerClient.LogPrevalidated()
			return nil
		}

		return performMFA(ciPipelineId, ciUserEmail, timeout, checkType, v, loggerClient)
	}

	_ = loggerClient.LogSuccessfulExecution()

	return nil
}

func performMFA(pipelineId int, user string, timeout int, checkType string, c vaultclient.VaultClient, loggerClient loggerclient.LoggerClient) error {
	// Write Secret + Check if Exists
	secretPath, err := c.WriteScratch(pipelineId, user)
	if err != nil {
		return loggerClient.LogFailedExecution(err.Error())
	}

	// Tell User To Delete Scratch code at Location
	c.LogMFAInstructions(user, loggerClient)

	// Check For Secret Deletion
	success := c.WaitForMFA(timeout, secretPath)

	err = c.Cleanup(success, secretPath, checkType)
	if err != nil {
		return loggerClient.LogFailedExecution(err.Error())
	}

	if success {
		_ = loggerClient.LogSuccessfulExecution()
	} else {
		return loggerClient.LogFailedExecution("  ‚ùå CI/CD run not authorized")
	}

	return nil
}
